<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>精神分析概念块茎</title>
    <style>
        /* 网页的CSS样式部分。通常您不需要修改这里。 */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        :root {
            --bg-color: #0a0a0a;
            --node-bg: #1a1a1a;
            --node-border: #33ff99;
            --node-text: #e0e0e0;
            --panel-bg: rgba(20, 20, 20, 0.97);
            --panel-border: #888;
            --highlight-color: #ff33cc;
            --line-color: rgba(51, 255, 153, 0.2);
            --line-highlight-color: rgba(255, 51, 204, 0.8);
            --font-family: 'Roboto Mono', monospace;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--bg-color); color: var(--node-text);
            font-family: var(--font-family); overflow: hidden; cursor: grab;
        }
        #type-nodes-container {
        position: fixed;
        top: 100px;
        left: 20px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 10px;
        }
        .type-node {
            background-color: var(--node-bg);
            border: 1px solid var(--highlight-color);
            color: var(--highlight-color);
            padding: 8px 12px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(255, 51, 204, 0.3);
            text-align: center;
        }
        .type-node:hover {
            background-color: var(--highlight-color);
            color: var(--bg-color);
            transform: scale(1.05);
        }
        #title-card {
            position: fixed; top: 20px; left: 20px; color: var(--node-border);
            z-index: 1000; font-size: 1.2em; text-shadow: 0 0 5px var(--node-border);
        }
        #title-card span { font-size: 0.7em; color: var(--panel-border); display: block; }
        #rhizome-map { position: relative; width: 100%; height: 100%; }
        .node {
            position: absolute; background-color: var(--node-bg);
            border: 1px solid var(--node-border); border-radius: 4px;
            padding: 10px 15px; cursor: pointer; user-select: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            animation: drift 20s infinite alternate ease-in-out;
            z-index: 10; box-shadow: 0 0 10px rgba(51, 255, 153, 0.3); font-size: 0.9em;
        }
        .node:hover { transform: scale(1.1); border-color: var(--highlight-color); z-index: 11; }
        .node.active { border-color: var(--highlight-color); box-shadow: 0 0 20px var(--highlight-color); transform: scale(1.15); z-index: 12; }
        @keyframes drift {
            0% { transform: translate(0, 0); } 50% { transform: translate(-5px, 10px); } 100% { transform: translate(0, 0); }
        }
        #connections { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        #connections line { stroke: var(--line-color); stroke-width: 1; transition: stroke 0.3s ease; }
        #connections line.highlight { stroke: var(--line-highlight-color); stroke-width: 2; }
        #info-panel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9);
            width: 90%; max-width: 700px; max-height: 85vh;
            background-color: var(--panel-bg); border: 1px solid var(--panel-border);
            border-radius: 5px; padding: 25px; box-shadow: 0 0 30px rgba(0,0,0,0.7);
            z-index: 100; opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease; overflow-y: auto;
        }
        #info-panel.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: all; }
        #info-panel h2 { margin-top: 0; color: var(--highlight-color); text-shadow: 0 0 5px var(--highlight-color); }
        #info-panel h3 { color: var(--node-border); border-bottom: 1px solid var(--line-color); padding-bottom: 5px; margin-top: 20px; }
        #info-panel p, #info-panel ul { line-height: 1.7; font-size: 0.9em; }
        #info-panel ul { padding-left: 20px; }
        #info-panel .close-btn { position: sticky; top: 15px; right: 15px; float: right; cursor: pointer; font-size: 1.5em; color: var(--panel-border); transition: color 0.2s ease, transform 0.2s ease; z-index: 101; background-color: var(--panel-bg); width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%; margin-right: -10px; margin-top: -10px;}
        #info-panel .close-btn:hover { color: var(--highlight-color); transform: rotate(90deg); }
        #info-panel .internal-link { color: var(--node-border); text-decoration: underline; cursor: pointer; transition: color 0.2s; }
        #info-panel .internal-link:hover { color: var(--highlight-color); }
        .connection-point { margin-top: 30px; padding: 15px; border: 1px dashed var(--panel-border); border-radius: 4px; }
        .connection-point h4 { margin-top: 0; color: var(--node-text); font-weight: bold; }
        .connection-point .meta { font-size: 0.8em; color: var(--panel-border); margin-bottom: 10px; }
        .connection-point .meta span { color: var(--highlight-color); }
        .viz-prompt { background-color: #111; border-left: 3px solid var(--node-border); padding: 10px; font-size: 0.85em; margin-top: 10px; }
        #info-panel { scrollbar-width: thin; scrollbar-color: var(--panel-border) var(--node-bg); }
        #info-panel::-webkit-scrollbar { width: 8px; }
        #info-panel::-webkit-scrollbar-track { background: var(--node-bg); border-radius: 4px; }
        #info-panel::-webkit-scrollbar-thumb { background-color: var(--panel-border); border-radius: 4px; border: 2px solid var(--node-bg); }
        #info-panel::-webkit-scrollbar-thumb:hover { background-color: var(--node-border); }
    </style>
</head>
<body>

    <!-- 网页的HTML结构部分。通常您不需要修改这里。 -->
    <div id="title-card">
        精神分析概念块茎
        <span>Psychoanalytic conceptual rhizomes</span>
    </div>
    <div id="type-nodes-container"></div>
    <svg id="connections"></svg>
    <div id="rhizome-map"></div>
    <div id="info-panel">
        <div class="close-btn">&times;</div>
        <div id="panel-content"></div>
    </div>

    <!-- 网页的JavaScript逻辑和数据部分。这是您未来主要的工作区域。 -->
    <script>
    const theoryData = {
        
        // ==================================================================
        // [区域 A]: 概念定义 (Concepts)
        // ==================================================================
        // 此处定义了地图上出现的每一个“节点”(概念)。
        // 格式: "英文id": { name: "中文名称", content: `HTML内容` }
        // 注意: 每个概念块之间需要用逗号 , 隔开。
        // ==================================================================
        concepts: {

            // --- ↓↓↓ 将AI生成的【概念代码块】粘贴到这里 ↓↓↓ ---
            
            // 示例 (您可以删除或保留此示例):
            "signifier-signified": {
                name: "能指与所指 (Signifier & Signified)",
                content: "<h2>能指与所指</h2><p><b>能指</b>是符号的声音或图像（如单词'树'），<b>所指</b>是其代表的概念。拉康强调，能指与所指的关系是任意且滑动的，意义是在能指链的运动中产生的，而非固定不变。<b>能指优先于所指</b>，并决定了主体的无意识结构。</p>"
            },
            "id-ego-superego": {
                name: "本我、自我、超我 (Id, Ego, Superego)",
                content: "<h2>本我、自我、超我</h2><p>弗洛伊德的经典结构。<b>本我</b>遵循快乐原则；<b>超我</b>代表内化的社会道德法则；<b>自我</b>则在现实原则下进行协调。拉康对此进行了重构：<b>自我</b>是镜像阶段形成的、充满误认的虚假构造；<b>超我</b>则成为一个发出“享乐吧！”命令的淫秽、严厉的律令。</p>"
            },
            "ideal-ego": {
                name: "理想自我 (Ideal Ego)",
                content: "<h2>理想自我 (想象性认同)</h2><p>主体通过<b>想象性认同</b>构建的、一个“我们想成为”的完美形象。它形成于镜像阶段，主体将他人的完整形象（小他者）<b>误认</b>为自身，以克服身体的破碎感。这是一种自恋性的、以形象为基础的认同。</p>"
            },
            "ego-ideal": {
                name: "自我理想 (Ego-Ideal)",
                content: "<h2>自我理想 (符号性认同)</h2><p>主体在<b>符号秩序（大他者）</b>中占据的位置，是从他者的凝视中确立的社会身份。它代表了“他人期望我成为什么”。从理想自我到自我理想的过渡，是俄狄浦斯情结的核心，标志着主体从想象界进入符号界。</p>"
            },
            "unconscious": {
                name: "无意识 (Unconscious)",
                content: "<h2>无意识</h2><p>拉康的核心观点：<b>“无意识的结构就像语言一样”</b>。它不是充满本能冲动的原始深渊，而是由<b>能指链</b>构成的、遵循语言逻辑（转喻与换喻）的“他者的话语”。主体是被这套符号系统所言说、所决定的。</p>"
            },
            "split-subject": {
                name: "主体的分裂 ($)",
                content: "<h2>主体的分裂 ($)</h2><p>主体在进入语言（符号界）时,必然经历的<b>根本性分裂</b>。由于语言无法完全表达主体的存在,主体永远是一个“被言说”的存在,其自身总有一部分被排除在符号之外。因此,主体内部永远存在着矛盾、匮乏和不一致性。</p>"
            },
            "oedipus-complex": {
                name: "俄狄浦斯情结",
                content: "<h2>俄狄浦斯情结</h2><p>主体进入符号界的关键过程。<b>第一阶段</b>：与母亲的想象性二元关系。<b>第二阶段</b>：“父亲之名”（代表符号法则）介入，带来阉割体验。<b>第三阶段</b>：主体认同父亲的法则，从认同<b>理想自我</b>转向认同<b>自我理想</b>，成功进入符号秩序。</p>"
            },
            "big-other": {
                name: "大他者 (Big Other)",
                content: "<h2>大他者 (Big Other)</h2><p>象征秩序的总体代表,是语言、法律、文化规范等构成的<b>虚拟坐标系</b>。它不仅是外部权威,更是主体内化的、用以理解世界和自身欲望的“第三方”视点。主体总是假设大他者存在,并向其寻求认可和意义的保证。</p><h3>核心功能/作用</h3><ul><li><b>意义的担保者:</b> 保证符号系统的稳定和意义的成立。</li><li><b>欲望的定位器:</b> 主体的</b>欲望</b>总是在“大他者想要什么？”的追问中形成的。</li><li><b>身份的授予者:</b> 提供社会身份和角色认同。</li></ul><h3>常见误解/补充说明</h3><p><b>误解:</b> 大他者不是一个具体的人或实体(如政府),而是一个<b>结构性的、符号性的位置</b>。<br><b>补充:</b> 大他者自身是<b>不完整、有缺陷的</b>(即“大他者不存在”),它无法提供最终的保证,这个裂隙是主体焦虑的根源。</p>"
            },
            "real": {
                name: "实在界 (The Real)",
                content: "<h2>实在界 (The Real)</h2><p><b>超越并抵抗符号化的、创伤性的现实内核</b>。它不是我们日常感知的“现实”,而是</b>符号界</b>无法捕捉、无法言说的部分,是意义网络的漏洞和断裂之处。它通常以创伤、恐怖、极度的</b>享乐</b>或无法解释的偶然事件的形式显现。</p>"
            },
            "imaginary": {
                name: "想象界 (Imaginary)",
                content: "<h2>想象界 (Imaginary)</h2><p><b>想象界</b>是拉康精神结构三界之一，是<b>自我 (ego)、认同、形象和欺骗</b>的领域。它源于主体与其自身形象的关系，其核心原型是<b>镜像阶段</b>。这是一个充满着二元对立、竞争和异化关系的维度，主体通过认同他者来构建自我，因此自我本质上是疏离和异化的。</p>"
            },
            "symbolic": {
                name: "符号界 (Symbolic)",
                content: "<h2>符号界 (Symbolic)</h2><p>由语言、法律、亲属关系、社会规范等构成的<b>象征性网络</b>，即<b>大他者</b>。它是人类脱离自然状态、进入文化社会的基础。我们通过符号界来理解世界、建立社会关系和形成自我认同。<b>主体</b>通过被命名、被纳入符号网络而诞生，但这个过程也必然导致其<b>分裂</b>。</p>"
            },
            "objet-petit-a": {
                name: "对象a (Objet petit a)",
                content: "<h2>对象a (Objet petit a)</h2><p><b></b>欲望</b>的诱因对象,是</b>主体</b>身上被符号化“阉割”后脱落下来的、</b>实在界</b>的残余</b>。它不是欲望的目标,而是<b>驱动欲望的原因</b>。它是一个虚幻的、看似能填补主体匮乏的“小东西”,表现为凝视、声音等局部对象。</p>"
            },
            "desire": {
                name: "欲望 (Desire)",
                content: "<h2>欲望 (Desire)</h2><p><b>永不满足的、由“匮乏”驱动的动力</b>。它不是对具体事物的简单需求(Need),而是对“他者之欲望”的欲望,即渴望被<b>大他者<b>承认和欲望着。它本质上是一种形而上的、由语言和</b>符号界</b>塑造的追求。一旦达到某个目标,欲望会立刻转向下一个目标。</p>"
            },
            "fantasy": {
                name: "幻象 (Fantasy)",
                content: "<h2>幻象 (Fantasy)</h2><p>主体为组织其</b>欲望</b>、掩盖<b>大他者<b>的不一致性和</b>实在界</b>的创伤而构建的<b>无意识叙事框架</b>。它不是对现实的逃避,而是<b>构建现实感的基础</b>,教导我们“如何去欲望”。</p>"
            },
            "jouissance": {
                name: "享乐 (Jouissance)",
                content: "<h2>享乐 (Jouissance)</h2><p>一种<b>超越“快乐原则”的、痛苦的、过度的快感</b>。它与死亡驱力相关,是</b>主体</b>在触及</b>实在界</b>时的体验。它不是舒适的满足,而是一种破坏性的、令人上瘾的“享受”,常常以</b>症候</b>的形式出现。</p>"
            },
            "symptom": {
                name: "症候 (Symptom)",
                content: "<h2>症候 (Symptom)</h2><p>一个携带了被压抑的真理的<b>密码化信息能指</b>。它是一种妥协形成,既表达了</b>主体</b>被禁止的</b>欲望</b>,又以一种扭曲的方式惩罚了这种欲望。在后期理论中,症候更被看作是主体组织其</b>享乐</b>的独特方式,是</b>实在界</b>的硬核。</p>"
            },
            "sinthome": {
                name: "圣状 (Sinthome)",
                content: "<h2>圣状 (Sinthome)</h2><p>拉康后期对<b>症候</b>的重塑，指症候在被精神分析穷尽其象征意义之后，所剩下的那个<b>无法被化约的、纯粹享乐的内核</b>。它不再是请求解读的“信息”，而是一种主体创造出来用以组织自身享乐，并维系其精神结构稳定的独特“技艺”或“发明”。</p>"
            },
            "name-of-the-father": {
                name: "父之名 (Name-of-the-Father)",
                content: "<h2>父之名 (Name-of-the-Father)</h2><p>一个<b>根本性的能指</b>,它代表了</b>符号界</b>的法则和权威。它的功能是将意义网络锚定下来,阻止能指的无限滑动,从而建立一个相对稳定的现实感。它将</b>欲望</b>置于法则之下。对它的<b>排除</b>是<b>精神病</b>结构的成因。</p>"
            },
            "masters-discourse": {
                name: "主人话语",
                content: "<h2>主人话语 (Master's Discourse)</h2><p>四种话语中最基本、最原始的模式,代表着权力和统治。其结构是 S1 → S2,即<b>主人能指 (S1)</b> 对<b>知识 (S2)</b> 发号施令,但这个过程总是产生一个剩余物——</b>对象a</b>。</p>"
            },
            "universitys-discourse": {
                name: "大学话语",
                content: "<h2>大学话语 (University's Discourse)</h2><p>知识伪装成中立、客观权威的话语模式。其结构是 S2 → a,即<b>知识 (S2)</b> 被置于主导地位,对<b>对象 (a)</b> 进行教育、规训和生产。但其背后隐藏的真理是<b>主人能指 (S1)</b>，是<b>意识形态</b>最常见的运作模式。</p>"
            },
            "hysterics-discourse": {
                name: "癔症话语",
                content: "<h2>癔症话语 (Hysteric's Discourse)</h2><p>质疑和挑战权威的话语模式。其结构是 $ → S1,即<b>分裂的主体 ($)</b> 作为行动者,不断地向<b>主人 (S1)</b> 提问,要求他生产出能够解释主体分裂和欲望的<b>知识 (S2)</b>。</p>"
            },
            "analysts-discourse": {
                name: "分析家话语",
                content: "<h2>分析家话语 (Analyst's Discourse)</h2><p>精神分析的话语,旨在颠覆其他话语模式。其结构是 a → $,即<b>分析家</b>占据了</b>对象a</b> 的位置,作为被分析者</b>欲望</b>的诱因,从而让<b>分裂的主体 ($)</b> 能够说出他自己的真理。</p>"
            },
            "ideology": {
                name: "意识形态 (Ideology)",
                content: "<h2>意识形态</h2><p>一套<b>无意识的、实践性的社会信念系统</b>。它并非简单的“虚假观念”,而是通过日常仪式、社会惯例和物质实践来建构我们对现实的体验,使其显得“自然而然”,从而掩盖社会内在的矛盾和权力关系。</p><h3>核心机制</h3><p>最强大的意识形态恰恰是我们<b>明知其虚假,但在行动上依然遵循</b>的那些规则(犬儒主义)。我们通过一些仪式性行为(如垃圾分类)来缓解内心罪恶感,从而让更大的系统(过度消费)得以继续运转。</p>"
            },
            "depressive-structure": {
                name: "抑郁的结构",
                content: "<h2>抑郁的结构</h2><p>当<b>大他者<b>作为意义担保者的功能彻底失效,其内在矛盾暴露无遗时,</b>主体</b>所陷入的<b>结构性瘫痪状态</b>。这不仅是个人情感低落,更是整个<b>意义坐标系的崩塌</b>,导致</b>欲望</b>、行动和未来想象力的全面悬置。它是一种社会性、哲学性的诊断,描述的是主体与意义世界关系的断裂。</p>"
            },
            "neurosis": {
                name: "神经症 (Neurosis)",
                content: "<h2>神经症 (Neurosis)</h2><p>主体结构的一种,其核心机制是<b>压抑 (Repression)</b>。神经症主体接受了</b>父之名</b>所代表的象征性阉割,进入了</b>符号界</b>,但对阉割的接受是不完全的。其核心问题是关于</b>欲望</b>和</b>享乐</b>的:“我的欲望是什么？”“他者想要我怎样？”日常的拖延、过度思虑、对权威的矛盾态度都可视为神经症特征。</p>"
            },
            "psychosis": {
                name: "精神病 (Psychosis)",
                content: "<h2>精神病 (Psychosis)</h2><p>主体结构的一种,其核心机制是<b>排除/拒绝 (Foreclosure)</b>。精神病主体未能将关键的能指——</b>父之名</b>——整合进其</b>符号界</b>中。这导致其符号世界出现一个“洞”,被排除的符号性法则从</b>实在界</b>以幻觉和妄想的形式回归。</p>"
            },
            "perversion": {
                name: "倒错 (Perversion)",
                content: "<h2>倒错 (Perversion)</h2><p>主体结构的一种,其核心机制是<b>否认 (Disavowal)</b>。倒错者清楚地知道象征性阉割(法则的限制),但他拒绝承认这对“他”适用。他不像神经症患者那样压抑欲望,而是致力于成为实现<b>大他者</b>之<b>享乐</b>的工具。</p>"
            },
            "superego-injunction": {
                name: "超我律令 (Superego Injunction)",
                content: "<h2>超我律令</h2><p>拉康对超我的独特解读。它不是一个禁止性的道德法则,而是一个悖论性的、淫秽的命令:<b>“享乐吧!” (Enjoy!)</b>。这个命令迫使主体去追求一种不可能的、过度的、痛苦的<b>享乐</b>,从而导致罪恶感和焦虑。它是<b>享乐</b>的代理者。</p>"
            },
            "dream": {
                name: "梦 (Dream)",
                content: "<h2>梦 (Dream)</h2><p>拉康遵循弗洛伊德的观点,认为<b>“梦是欲望的满足”</b>,并且是通往<b>无意识</b>的康庄大道。梦的运作(凝缩与移置)揭示了无意识的语言结构(换喻与转喻)。梦的内容是次要的,其<b>形式</b>和<b>结构</b>才是揭示主体真理的关键。</p>"
            },
            "thing": {
                name: "原质 (das Ding / The Thing)",
                content: "<h2>原质 (The Thing)</h2><p>主体因进入<b>符号界</b>而失去的、与母亲一体的<b>原初享乐对象</b>。它位于<b>实在界</b>的核心,是所有<b>欲望</b>和<b>驱力</b>最终指向的、但又永远无法到达的创伤性空洞。快乐原则正是为了与这个致命的“原质”保持距离而建立的。</p>"
            },
            "drive-persistence": {
                name: "驱力 (Drive)",
                content: "<h2>驱力 (Drive)</h2><p>与<b>欲望</b>不同,驱力不寻求在对象中获得满足,而是<b>围绕着失去的对象(对象a)进行永不休止的重复运动</b>。它的满足感(<b>享乐</b>)来自于这种重复本身,而非达到目标。拉康强调的是部分驱力(如口唇、肛门驱力),并最终将其与死亡驱力联系起来。</p>"
            }

            // --- ↑↑↑ 将AI生成的【概念代码块】粘贴到这里 ↑↑↑ ---

        },
        
        // ==================================================================
        // [区域 B]: 连接点 (Connection Points)
        // ==================================================================
        // 此处定义了概念之间的“连接关系”和对应的阐释。
        // 格式: { title: "连接标题",concepts: ["id1", "id2"], html: `HTML内容` }
        // 注意: 每个连接点块之间需要用逗号 , 隔开。
        // ==================================================================
        connectionPoints: [

            // --- ↓↓↓ 将AI生成的【连接点代码块】粘贴到这里 ↓↓↓ ---

            // 示例 (您可以删除或保留此示例):
            {
                title: "无意识与语言",
                type: "概念关联",
                concepts: ["unconscious", "signifier-signified", "big-other"],
                html: "<h4>无意识的结构就是语言能指的结构</h4><p>拉康认为<b>无意识</b>的结构与<b>能指</b>的结构是等值的。无意识不再是弗洛伊德式的本能，而是“他者的话语”，即来自于<b>大他者</b>（符号界）的语言和法则。分析能指的结构就等于分析无意识。</p>"
            },
            {
                title: "主体的分裂与符号化",
                type: "概念关联",
                concepts: ["split-subject", "symbolic", "real", "big-other"],
                html: "<h4>主体：实在界创伤与符号界建构的裂缝</h4><p>主体是<b>实在界</b>否定性与<b>大他者</b>（符号界）建构之间的“消失中介点”。当主体进入由<b>能指</b>构成的语言世界(<b>符号界</b>)时，其完整性被打破，成为<b>分裂的主体</b>，一个被符号秩序决定的“去中心化的主体”。</p>"
            },
            {
                title: "自我(Ego)的形成：误认与想象",
                type: "概念关联",
                concepts: ["id-ego-superego", "ideal-ego", "imaginary"],
                html: "<h4>自我是虚假的想象之物</h4><p>拉康认为<b>自我</b>（Ego）形成于<b>想象界</b>的镜像阶段，是对他人形象的<b>误认</b>，因此是虚假的。这种以他人形象自居的过程，构建了<b>理想自我</b>，并从一开始就伴随着与他者的<b>侵凌性</b>竞争关系。</p>"
            },
            {
                title: "超我(Superego)与自我理想",
                type: "概念关联",
                concepts: ["id-ego-superego", "ego-ideal", "superego-injunction"],
                html: "<h4>自我理想即超我</h4><p>“拉康的<b>自我理想</b>就是弗洛伊德的<b>超我</b>”。它代表了内化了的社会法则，通过符号性认同形成，对自我进行具有压抑性的统治。其最终形态是发出“享乐吧！”命令的<b>超我律令</b>。</p>"
            },
            {
                title: "俄狄浦斯情结：两种认同的转换",
                type: "概念关联",
                concepts: ["oedipus-complex", "ideal-ego", "ego-ideal", "name-of-the-father"],
                html: "<h4>从理想自我到自我理想的过渡</h4><p><b>俄狄浦斯情结</b>是主体通过<b>父之名</b>的介入，从与母亲的想象性关系，转向认同社会法则的过程。拉康称之为从“<b>理想自我</b>”（我想成为的样子）向“<b>自我理想</b>”（社会期望我成为的样子）的过渡。</p>"
            },
            {
                title: "对象a：欲望之因与实在界剩余",
                type: "概念关联",
                concepts: ["objet-petit-a", "desire", "real", "split-subject"],
                html: "<h4>无法被化简的剩余物</h4><p><b>对象a</b>是被符号秩序阉割后，依附于原始客体的快感<b>剩余物</b>，是<b>实在界</b>的残余。它不是欲望的对象，而是<b>欲望</b>的“原因”。<b>分裂的主体</b>正是围绕着对象a这个不可能的空白建构起来的。</p>"
            },
            {
                title: "幻象的公式：$◇a",
                type: "概念关联",
                concepts: ["fantasy", "split-subject", "objet-petit-a", "desire"],
                html: "<h4>幻象是结构欲望的方式</h4><p>幻象($◇a)是<b>分裂的主体</b>($)与<b>对象a</b>成功架构主体之现实的方式。它为我们提供了“如何去欲望”的图式或框架，是主体在<b>大他者</b>的质询中回应自身<b>欲望</b>的方式。</p>"
            },
            {
                title: "症候：加密的能指与享乐的组织",
                type: "概念关联",
                concepts: ["symptom", "unconscious", "jouissance", "signifier-signified"],
                html: "<h4>症候是身体内的词语</h4><p>拉康认为，<b>症候</b>是一个被压抑的、加密的<b>能指</b>，是<b>无意识</b>创伤的回归。同时，它也是主体组织其剩余<b>享乐</b>的一种方式。精神分析的终结，是主体能够认同其症候，在其中辨认出自身存在的唯一支撑。</p>"
            },
            {
                title: "意识形态与梦的形式",
                type: "概念关联",
                concepts: ["ideology", "dream", "unconscious", "fantasy"],
                html: "<h4>意识形态具有梦的形式</h4><p>意识形态研究的关键在于其形式，而非内容。如同<b>梦</b>的运作，意识形态通过移置和凝缩等方式，构建一个无意识的<b>幻象</b>框架，从而掩盖社会对抗的真相。它是作用于<b>无意识</b>层面的运作机制。</p>"
            },
            {
                title: "原质与享乐",
                type: "概念关联",
                concepts: ["thing", "jouissance", "real", "superego-injunction"],
                html: "<h4>原质是实在界之核</h4><p><b>原质</b>是主体失去的原初享乐对象，是<b>实在界</b>的核心，其能量体现为过度的、痛苦的<b>享乐</b>。符号法则正是围绕禁止接近原质而建立的。而<b>超我律令</b>则悖论性地命令主体去接近这种不可能的享乐。</p>"
            },
            {
                title: "驱力与欲望的根本对立",
                type: "概念关联",
                concepts: ["drive-persistence", "desire", "jouissance", "objet-petit-a"],
                html: "<h4>驱力围绕空无的重复</h4><p><b>欲望</b>的目的是追求满足，但总是在幻象中滑向别处。而<b>驱力</b>（死亡驱力）则不求满足，它仅仅是围绕着<b>对象a</b>这个空无进行永不休止的重复，并在这种重复中获得一种痛苦的<b>享乐</b>。它代表了一种不向欲望让步的伦理立场。</p>"
            },
            {
                title: "圣状：症候的享乐内核",
                type: "概念关联",
                concepts: ["sinthome", "symptom", "jouissance", "name-of-the-father"],
                html: "<h4>一种超越意义的享乐模式</h4><p><b>圣状</b>是<b>症候</b>在意义被穷尽后，剩下的那个纯粹<b>享乐</b>的内核。它不再是需要解读的密码，而是主体用以组织其享乐的独特“技艺”。在<b>父之名</b>功能缺失时，圣状可作为“第四个环”，捆绑三界，维系主体稳定。</p>"
            },
            {
                title: "四种话语的结构",
                type: "概念关联",
                concepts: ["masters-discourse", "universitys-discourse", "hysterics-discourse", "analysts-discourse"],
                html: "<h4>社会链接的四种模式</h4><p>拉康用<b>主人话语</b>、<b>大学话语</b>、<b>癔症话语</b>和<b>分析家话语</b>这四种结构，揭示了权力、知识、质疑和颠覆在社会关系中的循环与转换。每种话语都是对其他话语的旋转，揭示了能指、知识、主体和剩余物(对象a)在不同社会关系中的位置变化。</p>"
            },
            {
                title: "三种主体结构",
                type: "概念关联",
                concepts: ["neurosis", "psychosis", "perversion", "name-of-the-father"],
                html: "<h4>主体与法则的三种关系</h4><p><b>神经症</b>通过“压抑”来接受<b>父之名</b>，但仍存疑。<b>精神病</b>通过“排除”拒绝了父之名，导致符号界出现空洞。<b>倒错</b>通过“否认”来承认法则但将自身置于例外，致力于成为他者享乐的工具。这三种结构是主体应对象征性阉割的不同方式。</p>"
            },
            {
                title: "主人话语、主体、欲望",
                type: "概念关联",
                concepts: ["masters-discourse", "split-subject", "objet-petit-a", "desire", "jouissance"],
                html: "<h4><b>主人话语</b>通过掩盖<b>分裂的主体</b>的匮乏，必然生产出作为<b>欲望</b>诱因的剩余物<b>对象a</b>。</h4><p><b>主人话语</b> (S1→S2) 试图建立一个完整的知识体系，但其真相是<b>分裂的主体</b> ($) 的根本匮乏。这个权力运作总会产生无法被完全符号化的剩余物——<b>对象a</b>。例如，“算法推荐”就是一种当代的<b>主人话语</b>。平台 (S1) 发出“滑动！”的命令，驱动用户数据 (S2) 的运作。其背后是用户的空虚 ($)。这个过程生产出的<b>对象a</b>，并非具体内容，而是“下一个会更精彩”的虚幻承诺，一种驱动用户不断滑动的、过度的<b>享乐</b>残余，它恰恰是维持系统运转的<b>欲望</b>根源。</p>"
            },
            {
                title: "大学话语与意识形态",
                type: "概念关联",
                concepts: ["universitys-discourse", "ideology", "split-subject", "objet-petit-a"],
                html: "<h4><b>大学话语</b>是<b>意识形态</b>最精妙的运作形式，它通过中立的知识生产出<b>分裂的主体</b>。</h4><p>在<b>大学话语</b>中，知识(S2)被置于主导地位，将个体规训为待处理的<b>对象a</b>。然而，其背后隐藏着主人律令(S1)的非理性命令（如“利润最大化”）。当个体被这套知识体系成功塑造后，便成为一个<b>分裂的主体</b>($)：一个看似合格的社会成员，但其真实欲望却被压抑和异化。现代企业“数据驱动”文化就是典型案例，员工在KPI的压迫下被掏空，成为<b>意识形态</b>的完美载体。</p>"
            },
            {
                title: "癔症话语的质问",
                type: "概念关联",
                concepts: ["hysterics-discourse", "split-subject", "big-other", "real", "symptom", "symbolic", "ideology", "masters-discourse"],
                html: "<h4><b>癔症话语</b>通过对<b>大他者</b>的持续质问，旨在揭露其内在矛盾，从而迫使创伤性的<b>实在界</b>显现。</h4><p>作为<b>分裂的主体</b>，癔症患者不断质问代表<b>意识形态</b>和权威的<b>主人能指</b>（S1），其目的并非寻求答案，而是挑衅性地揭露<b>大他者</b>自身的无能与虚假。这种质问旨在撕开<b>符号</b>秩序的伪装，暴露其无法自圆其说的裂隙，即“<b>大他者</b>不存在”这一事实。当<b>大他者</b>的保证失效时，其所掩盖的创伤性内核——即<b>实在界</b>——便会入侵。例如，“吹哨人”通过挑战国家话语，揭示了其温情面纱背后冰冷的监控机器，这就是一种典型的<b>癔症话语</b>策略，它迫使社会直面<b>大他者</b>的崩溃和<b>实在界</b>的降临。</p>"
            },
            {
                title: "“内卷”与燃尽：当代精神困境",
                type: "现象分析",
                concepts: ["depressive-structure", "superego-injunction", "jouissance", "big-other"],
                html: "<h4>大他者衰落下的抑郁结构</h4><p>当“努力就能成功”的传统<b>大他者</b>承诺失效，社会陷入一种结构性瘫痪。<b>超我律令</b>转变为“必须享乐！必须与众不同！”，驱使主体投入“内卷”式的军备竞赛。这种竞争无法带来快乐，反而是一种痛苦的<b>享乐</b>。最终，欲望在无尽的追逐中燃尽(burnout)，导致行动力瘫痪，这正是当代<b>抑郁的结构</b>。</p>"
            },
            {
                title: "互联网上的男女对立",
                type: "现象分析",
                concepts: ["big-other", "jouissance", "imaginary"],
                html: "<h4>大他者失效下的攻击性享乐</h4><p>当统一的道德叙事（<b>大他者</b>）在互联网空间失效，稳定的两性关系符号界随之崩塌。主体间的关系退行到充满竞争和攻击性的<b>想象界</b>二元对立。沟通的目的不再是寻求理解，而是通过辱骂和贬低对方群体来获得一种前符号的、暴力的<b>享乐</b>。</p>"
            },
            {
                title: "“网络社群”与极端身份政治",
                type: "现象分析",
                concepts: ["psychosis", "perversion", "name-of-the-father", "symbolic"],
                html: "<h4>象征法则缺席下的另类秩序</h4><p>在某些极端网络社群中，保证公共理性的<b>父之名</b>被“排除”。为填补空洞，社群自行“发明”一个新的绝对法则（如“哥哥绝对正确”，“围绕着女体崇拜的男权”，“反男性的极端女权”）来重构<b>符号界</b>。这种结构类似于<b>精神病</b>（对内坚信不疑，视外部为迫害者），或是一种<b>倒错</b>结构（将自身法则奉为更高级的真理，并从攻击“敌人”中获得享乐）。</p>"
            },
            {
                title: "消费主义下的“选择自由”",
                type: "现象分析",
                concepts: ["desire", "objet-petit-a", "depressive-structure"],
                html: "<h4>欲望过剩与主体的瘫痪</h4><p>当代消费主义命令我们“尽情选择！”，导致<b>欲望</b>被过度生产。市场将每样商品都包装成能填补内心空虚的<b>对象a</b>。主体在追逐无数<b>对象a</b>的过程中耗尽精力，最终发现没有一个能真正满足匮乏，导致欲望衰竭和行动力瘫痪，陷入“做什么都无所谓”的<b>抑郁结构</b>。</p>"
            },
            {
                title: "网络社群中的表演式反串",
                type: "现象分析",
                concepts: ["fantasy", "split-subject", "objet-petit-a", "imaginary"],
                html: "<h4>为捕获“注视”而搭建的幻象舞台</h4><p>“一眼假”的反串是一种精心构建的<b>幻象</b>，它利用并暴露了<b>主体的分裂</b>——表演者和观众都清楚表演者与角色间的鸿沟。其最终目的，是为了捕获那个难以捉摸的<b>对象a</b>，即他人的“注视”或“反应”。这种在<b>想象界</b>层面与他者的互动，其“反应”本身就是支撑这场幻象表演的欲望诱因。</p>"
            },
            {
                title: "incel",
                type: "现象分析",
                concepts: ["real", "fantasy", "jouissance", "objet-petit-a", "symptom", "desire"],
                html: "<h4><b>幻象</b>作为屏障，将<b>实在界</b>的创伤转化为一种病态的<b>享乐</b>。</h4><p>面对“性关系不存在”这一<b>实在界</b>的创伤性内核，主体无法承受其根本性的缺失。因此，一个强大的<b>幻象</b>框架被构建起来（如“红丸理论”），为这种创伤赋予了具体的、可归罪的叙事。这个<b>幻象</b>的真正功能并非解决痛苦，而是组织和维持一种特定的、病态的<b>享乐</b>（Jouissance）。主体通过沉浸在受害者叙事中，从自身的失败和痛苦里获得了一种过度的快感，享受的不是性，而是“关于无法获得性的痛苦”本身。</p>"
            }



            // --- ↑↑↑ 将AI生成的【连接点代码块】粘贴到这里 ↑↑↑ ---

        ]
    };

    // ==================================================================
    // [区域 C]: 核心渲染逻辑
    // ==================================================================
    // 以下是驱动整个网页工作的核心代码。
    // 通常情况下,您完全不需要修改这部分内容。
    // ==================================================================
    document.addEventListener('DOMContentLoaded', () => {
        const map = document.getElementById('rhizome-map');
        const svg = document.getElementById('connections');
        const infoPanel = document.getElementById('info-panel');
        const panelContent = document.getElementById('panel-content');
        const closeBtn = document.querySelector('.close-btn');
        const allConcepts = { ...theoryData.concepts };
        const allConnections = buildConnections(allConcepts, theoryData.connectionPoints);
        const typeNodesContainer = document.getElementById('type-nodes-container');
        const connectionTypes = new Map();
        theoryData.connectionPoints.forEach(p => {
            if (!p.type) return;
            if (!connectionTypes.has(p.type)) {
                connectionTypes.set(p.type, []);
            }
            connectionTypes.get(p.type).push(p);
        });

        connectionTypes.forEach((points, type) => {
            const typeNode = document.createElement('div');
            typeNode.className = 'type-node';
            typeNode.textContent = type;
            typeNode.addEventListener('click', () => showTypePanel(type, points));
            typeNodesContainer.appendChild(typeNode);
        });
        Object.keys(allConcepts).forEach((key, index) => {
            const node = document.createElement('div');
            node.className = 'node';
            node.id = key;
            node.textContent = allConcepts[key].name;
            map.appendChild(node);
            updateLayout(); // 首次加载时调用
            window.addEventListener('resize', updateLayout);
        });

        const nodes = document.querySelectorAll('.node');
        let activeNode = null, isDragging = false, offset = { x: 0, y: 0 };

        function drawConnections() {
            svg.innerHTML = '';
            const drawn = new Set();
            Object.keys(allConnections).forEach(key => {
                const startNode = document.getElementById(key);
                if (!startNode) return;
                const startRect = startNode.getBoundingClientRect();
                allConnections[key].forEach(connKey => {
                    const pair = [key, connKey].sort().join('-');
                    if (drawn.has(pair)) return;
                    const endNode = document.getElementById(connKey);
                    if (endNode) {
                        const endRect = endNode.getBoundingClientRect();
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', startRect.left + startRect.width / 2);
                        line.setAttribute('y1', startRect.top + startRect.height / 2);
                        line.setAttribute('x2', endRect.left + endRect.width / 2);
                        line.setAttribute('y2', endRect.top + endRect.height / 2);
                        line.dataset.start = key; line.dataset.end = connKey;
                        svg.appendChild(line);
                        drawn.add(pair);
                    }
                });
            });
        }
        function repositionNodes() {
            const nodes = document.querySelectorAll('.node');
            const totalNodes = Object.keys(allConcepts).length;
            const conceptKeys = Object.keys(allConcepts);

            conceptKeys.forEach((key, index) => {
                const node = document.getElementById(key);
                if (!node) return;

                const angle = (index / totalNodes) * 2 * Math.PI;
                const radius = Math.min(window.innerWidth, window.innerHeight) * 0.38; // 稍微减小半径以避免边缘内容被裁切
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                // 使用 offsetWidth/Height 可以更精确地居中节点
                node.style.left = `${centerX + radius * Math.cos(angle) - node.offsetWidth / 2}px`;
                node.style.top = `${centerY + radius * Math.sin(angle) - node.offsetHeight / 2}px`;
            });
        }
        function updateLayout() {
            repositionNodes();
            // 加一个短暂的延迟确保DOM更新后再绘制连线，避免闪烁
            setTimeout(drawConnections, 50); 
        }
        function showTypePanel(type, points) {
            document.querySelector('.node.active')?.classList.remove('active');
            document.querySelectorAll('#connections line.highlight').forEach(l => l.classList.remove('highlight'));

            let contentHTML = `<h2>关联类型: <span style="color: var(--node-border);">${type}</span></h2>`;
            
            points.forEach(p => {
                const conceptsInvolved = p.concepts
                    .map(c => allConcepts[c] ? `<span class="internal-link" data-target="${c}">${allConcepts[c].name}</span>` : '')
                    .join(' & ');

                contentHTML += `<div class="connection-point">
                    <div class="meta">主题: <span>${p.title}</span><br>核心概念: ${conceptsInvolved}</div>
                    ${p.html}
                </div>`;
            });

            panelContent.innerHTML = contentHTML;
            infoPanel.classList.add('visible');
            infoPanel.scrollTop = 0;

            panelContent.querySelectorAll('.internal-link').forEach(link => {
                link.addEventListener('click', (e) => showPanel(e.target.dataset.target));
            });
        }

        function showPanel(key) {
            document.querySelector('.node.active')?.classList.remove('active');
            document.querySelectorAll('#connections line.highlight').forEach(l => l.classList.remove('highlight'));
            
            const node = document.getElementById(key);
            if (!node) return;
            node.classList.add('active');
            
            document.querySelectorAll(`#connections line[data-start="${key}"], #connections line[data-end="${key}"]`)
                .forEach(l => l.classList.add('highlight'));

            let contentHTML = allConcepts[key].content;
            const relatedConnections = theoryData.connectionPoints.filter(p => p.concepts.includes(key));
            
            if (relatedConnections.length > 0) {
                contentHTML += `<h3>动态连接点 / Dynamic Connections</h3>`;
                relatedConnections.forEach(p => {
                    const otherConcepts = p.concepts.filter(c => c !== key)
                        .map(c => `<span class="internal-link" data-target="${c}">${allConcepts[c].name}</span>`).join(' & ');
                    contentHTML += `<div class="connection-point">
                        <div class="meta">主题: <span>${p.title}</span><br>关联类型: ${p.type || '未定义'}<br>核心关联: ${otherConcepts}</div>
                        ${p.html}
                    </div>`;
                });
            }
            
            panelContent.innerHTML = contentHTML;
            infoPanel.classList.add('visible');
            infoPanel.scrollTop = 0;
            
            panelContent.querySelectorAll('.internal-link').forEach(link => {
                link.addEventListener('click', (e) => showPanel(e.target.dataset.target));
            });
        }

        nodes.forEach(node => {
            let dragCheck = false;
            node.addEventListener('mousedown', (e) => {
                dragCheck = false;
                setTimeout(() => dragCheck = true, 200);
                isDragging = true;
                activeNode = node;
                offset = { x: e.clientX - node.offsetLeft, y: e.clientY - node.offsetTop };
                node.style.animation = 'none';
            });
            node.addEventListener('click', () => { if (!dragCheck) showPanel(node.id); });
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && activeNode) {
                e.preventDefault();
                activeNode.style.left = `${e.clientX - offset.x}px`;
                activeNode.style.top = `${e.clientY - offset.y}px`;
                drawConnections();
            }
        });
        document.addEventListener('mouseup', () => {
            if (isDragging) { // 检查是否真的在拖拽状态
                if (activeNode) {
                    activeNode.style.animation = ''; // 恢复节点的漂浮动画
                    activeNode = null; // 清理 activeNode，好习惯
                }
                isDragging = false; // 无论鼠标在哪里松开，都结束拖拽
            }
        });
        closeBtn.addEventListener('click', () => {
            infoPanel.classList.remove('visible');
            document.querySelector('.node.active')?.classList.remove('active');
            document.querySelectorAll('#connections line.highlight').forEach(l => l.classList.remove('highlight'));
        });

        function buildConnections(concepts, points) {
            const connections = {};
            Object.keys(concepts).forEach(key => connections[key] = new Set());
            points.forEach(p => {
                for (let i = 0; i < p.concepts.length; i++) {
                    for (let j = i + 1; j < p.concepts.length; j++) {
                        connections[p.concepts[i]].add(p.concepts[j]);
                        connections[p.concepts[j]].add(p.concepts[i]);
                    }
                }
            });
            Object.keys(connections).forEach(key => connections[key] = Array.from(connections[key]));
            return connections;
        }

        setTimeout(drawConnections, 100);
        window.addEventListener('resize', drawConnections);
    });
    </script>
</body>
</html>
